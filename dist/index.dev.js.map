{"version":3,"file":"index.dev.js","sources":["../src/utils.ts","../src/gridbounds.ts","../src/markermanager.ts"],"sourcesContent":["/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @ignore\n *\n * @param lng\n */\nfunction lngToX(lng) {\n    return 1 + lng / 180;\n}\n/**\n * @ignore\n *\n * @param {number} lat\n * @returns {number}\n */\nfunction latToY(lat) {\n    const sinofphi = Math.sin((lat * Math.PI) / 180);\n    return 1 - (0.5 / Math.PI) * Math.log((1 + sinofphi) / (1 - sinofphi));\n}\n/**\n * @ignore\n *\n * @param latlng\n * @param zoom\n */\nexport function latLngToPixel(latlng, zoom) {\n    return new google.maps.Point(~~(0.5 + lngToX(latlng.lng()) * (2 << (zoom + 6))), ~~(0.5 + latToY(latlng.lat()) * (2 << (zoom + 6))));\n}\n//# sourceMappingURL=utils.js.map","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Helper class to create a bounds of INT ranges.\n * @ignore\n */\nexport class GridBounds {\n    /**\n     *\n     * @param bounds\n     * @param z\n     */\n    constructor(bounds, z) {\n        // [sw, ne]\n        this.z = z;\n        this.minX = Math.min(bounds[0].x, bounds[1].x);\n        this.maxX = Math.max(bounds[0].x, bounds[1].x);\n        this.minY = Math.min(bounds[0].y, bounds[1].y);\n        this.maxY = Math.max(bounds[0].y, bounds[1].y);\n    }\n    /**\n     * Returns true if this bounds equal the given bounds.\n     * @param {GridBounds} gridBounds GridBounds The bounds to test.\n     * @return {Boolean} This Bounds equals the given GridBounds.\n     */\n    equals(gridBounds) {\n        if (this.maxX === gridBounds.maxX &&\n            this.maxY === gridBounds.maxY &&\n            this.minX === gridBounds.minX &&\n            this.minY === gridBounds.minY) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Returns true if this bounds (inclusively) contains the given point.\n     * @param {Point} point  The point to test.\n     * @return {Boolean} This Bounds contains the given Point.\n     */\n    containsPoint(point) {\n        return (this.minX <= point.x &&\n            this.maxX >= point.x &&\n            this.minY <= point.y &&\n            this.maxY >= point.y);\n    }\n}\n//# sourceMappingURL=gridbounds.js.map","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/// <reference types=\"@types/google.maps\" />\nimport { latLngToPixel } from \"./utils\";\nimport { GridBounds } from \"./gridbounds\";\n/**\n * Creates a new MarkerManager that will show/hide markers on a map.\n */\nclass MarkerManager {\n    /**\n     * @constructor\n     * @param map The map to manage.\n     * @param {Options} options\n     */\n    constructor(map, { maxZoom = 19, trackMarkers, shown = true, borderPadding = 100 }) {\n        this._tileSize = 1024;\n        this._map = map;\n        this._mapZoom = map.getZoom();\n        this._maxZoom = maxZoom;\n        this._trackMarkers = trackMarkers;\n        // The padding in pixels beyond the viewport, where we will pre-load markers.\n        this._swPadding = new google.maps.Size(-borderPadding, borderPadding);\n        this._nePadding = new google.maps.Size(borderPadding, -borderPadding);\n        this._gridWidth = {};\n        this._grid = [];\n        this._grid[this._maxZoom] = [];\n        this._numMarkers = {};\n        this._numMarkers[this._maxZoom] = 0;\n        this.shownMarkers = 0;\n        this.shown = shown;\n        google.maps.event.addListenerOnce(map, \"idle\", () => {\n            this._initialize();\n        });\n    }\n    _initialize() {\n        const mapTypes = this._map.mapTypes;\n        // Find max zoom level\n        let mapMaxZoom = 1;\n        for (const sType in mapTypes) {\n            if (sType in mapTypes &&\n                mapTypes.get(sType) &&\n                mapTypes.get(sType).maxZoom === \"number\") {\n                const mapTypeMaxZoom = this._map.mapTypes.get(sType).maxZoom;\n                if (mapTypeMaxZoom > mapMaxZoom) {\n                    mapMaxZoom = mapTypeMaxZoom;\n                }\n            }\n        }\n        google.maps.event.addListener(this._map, \"dragend\", this._onMapMoveEnd.bind(this));\n        google.maps.event.addListener(this._map, \"idle\", this._onMapMoveEnd.bind(this));\n        google.maps.event.addListener(this._map, \"zoom_changed\", this._onMapMoveEnd.bind(this));\n        this.resetManager();\n        this._shownBounds = this._getMapGridBounds();\n        google.maps.event.trigger(this, \"loaded\");\n    }\n    /**\n     * This closure provide easy access to the map.\n     * They are used as callbacks, not as methods.\n     * @param marker Marker to be removed from the map\n     */\n    _removeOverlay(marker) {\n        marker.setMap(null);\n        this.shownMarkers--;\n    }\n    /**\n     * This closure provide easy access to the map.\n     * They are used as callbacks, not as methods.\n     * @param marker Marker to be added to the map\n     */\n    _addOverlay(marker) {\n        if (this.shown) {\n            marker.setMap(this._map);\n            this.shownMarkers++;\n        }\n    }\n    /**\n     * Initializes MarkerManager arrays for all zoom levels\n     * Called by constructor and by clearAllMarkers\n     */\n    resetManager() {\n        let mapWidth = 256;\n        for (let zoom = 0; zoom <= this._maxZoom; ++zoom) {\n            this._grid[zoom] = [];\n            this._numMarkers[zoom] = 0;\n            this._gridWidth[zoom] = Math.ceil(mapWidth / this._tileSize);\n            mapWidth <<= 1;\n        }\n    }\n    /**\n     * Removes all markers in the manager, and\n     * removes any visible markers from the map.\n     */\n    clearMarkers() {\n        this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n        this.resetManager();\n    }\n    /**\n     * Gets the tile coordinate for a given latlng point.\n     *\n     * @param {LatLng} latlng The geographical point.\n     * @param {Number} zoom The zoom level.\n     * @param {google.maps.Size} padding The padding used to shift the pixel coordinate.\n     *               Used for expanding a bounds to include an extra padding\n     *               of pixels surrounding the bounds.\n     * @return {GPoint} The point in tile coordinates.\n     *\n     */\n    _getTilePoint(latlng, zoom, padding) {\n        const pixelPoint = latLngToPixel(latlng, zoom);\n        const point = new google.maps.Point(Math.floor((pixelPoint.x + padding.width) / this._tileSize), Math.floor((pixelPoint.y + padding.height) / this._tileSize));\n        return point;\n    }\n    /**\n     * Finds the appropriate place to add the marker to the grid.\n     * Optimized for speed; does not actually add the marker to the map.\n     * Designed for batch-_processing thousands of markers.\n     *\n     * @param {Marker} marker The marker to add.\n     * @param {Number} minZoom The minimum zoom for displaying the marker.\n     * @param {Number} maxZoom The maximum zoom for displaying the marker.\n     */\n    _addMarkerBatch(marker, minZoom, maxZoom) {\n        const mPoint = marker.getPosition();\n        marker.set(\"__minZoom\", minZoom);\n        // Tracking markers is expensive, so we do this only if the\n        // user explicitly requested it when creating marker manager.\n        if (this._trackMarkers) {\n            google.maps.event.addListener(marker, \"changed\", (marker, oldPoint, newPoint) => {\n                this._onMarkerMoved(marker, oldPoint, newPoint);\n            });\n        }\n        const gridPoint = this._getTilePoint(mPoint, maxZoom, new google.maps.Size(0, 0));\n        for (let zoom = maxZoom; zoom >= minZoom; zoom--) {\n            const cell = this._getGridCellCreate(gridPoint.x, gridPoint.y, zoom);\n            cell.push(marker);\n            gridPoint.x = gridPoint.x >> 1;\n            gridPoint.y = gridPoint.y >> 1;\n        }\n    }\n    /**\n     * Returns whether or not the given point is visible in the shown bounds. This\n     * is a helper method that takes care of the corner case, when shownBounds have\n     * negative minX value.\n     *\n     * @param {Point} point a point on a grid.\n     * @return {Boolean} Whether or not the given point is visible in the currently\n     * shown bounds.\n     */\n    _isGridPointVisible(point) {\n        const vertical = this._shownBounds.minY <= point.y && point.y <= this._shownBounds.maxY;\n        const minX = this._shownBounds.minX;\n        let horizontal = minX <= point.x && point.x <= this._shownBounds.maxX;\n        if (!horizontal && minX < 0) {\n            // Shifts the negative part of the rectangle. As point.x is always less\n            // than grid width, only test shifted minX .. 0 part of the shown bounds.\n            const width = this._gridWidth[this._shownBounds.z];\n            horizontal = minX + width <= point.x && point.x <= width - 1;\n        }\n        return vertical && horizontal;\n    }\n    /**\n     * Reacts to a notification from a marker that it has moved to a new location.\n     * It scans the grid all all zoom levels and moves the marker from the old grid\n     * location to a new grid location.\n     *\n     * @param {Marker} marker The marker that moved.\n     * @param {LatLng} oldPoint The old position of the marker.\n     * @param {LatLng} newPoint The new position of the marker.\n     */\n    _onMarkerMoved(marker, oldPoint, newPoint) {\n        // NOTE: We do not know the minimum or maximum zoom the marker was\n        // added at, so we start at the absolute maximum. Whenever we successfully\n        // remove a marker at a given zoom, we add it at the new grid coordinates.\n        let zoom = this._maxZoom;\n        let changed = false;\n        const oldGrid = this._getTilePoint(oldPoint, zoom, new google.maps.Size(0, 0));\n        const newGrid = this._getTilePoint(newPoint, zoom, new google.maps.Size(0, 0));\n        while (zoom >= 0 && (oldGrid.x !== newGrid.x || oldGrid.y !== newGrid.y)) {\n            const cell = this._getGridCellNoCreate(oldGrid.x, oldGrid.y, zoom);\n            if (cell) {\n                if (this._removeMarkerFromCell(cell, marker)) {\n                    this._getGridCellCreate(newGrid.x, newGrid.y, zoom).push(marker);\n                }\n            }\n            // For the current zoom we also need to update the map. Markers that no\n            // longer are visible are removed from the map. Markers that moved into\n            // the shown bounds are added to the map. This also lets us keep the count\n            // of visible markers up to date.\n            if (zoom === this._mapZoom) {\n                if (this._isGridPointVisible(oldGrid)) {\n                    if (!this._isGridPointVisible(newGrid)) {\n                        this._removeOverlay(marker);\n                        changed = true;\n                    }\n                }\n                else {\n                    if (this._isGridPointVisible(newGrid)) {\n                        this._addOverlay(marker);\n                        changed = true;\n                    }\n                }\n            }\n            oldGrid.x = oldGrid.x >> 1;\n            oldGrid.y = oldGrid.y >> 1;\n            newGrid.x = newGrid.x >> 1;\n            newGrid.y = newGrid.y >> 1;\n            --zoom;\n        }\n        if (changed) {\n            this._notifyListeners();\n        }\n    }\n    /**\n     * Removes marker from the manager and from the map\n     * (if it's currently visible).\n     * @param {GMarker} marker The marker to delete.\n     */\n    removeMarker(marker) {\n        let zoom = this._maxZoom;\n        let changed = false;\n        const point = marker.getPosition();\n        const grid = this._getTilePoint(point, zoom, new google.maps.Size(0, 0));\n        while (zoom >= 0) {\n            const cell = this._getGridCellNoCreate(grid.x, grid.y, zoom);\n            if (cell) {\n                this._removeMarkerFromCell(cell, marker);\n            }\n            // For the current zoom we also need to update the map. Markers that no\n            // longer are visible are removed from the map. This also lets us keep the count\n            // of visible markers up to date.\n            if (zoom === this._mapZoom) {\n                if (this._isGridPointVisible(grid)) {\n                    this._removeOverlay(marker);\n                    changed = true;\n                }\n            }\n            grid.x = grid.x >> 1;\n            grid.y = grid.y >> 1;\n            --zoom;\n        }\n        if (changed) {\n            this._notifyListeners();\n        }\n        this._numMarkers[marker.get(\"__minZoom\")]--;\n    }\n    /**\n     * Add many markers at once.\n     * Does not actually update the map, just the internal grid.\n     *\n     * @param {Array of Marker} markers The markers to add.\n     * @param {Number} minZoom The minimum zoom level to display the markers.\n     * @param {Number} maxZoom The maximum zoom level to display the markers.\n     */\n    addMarkers(markers, minZoom, maxZoom) {\n        maxZoom = this._getOptmaxZoom(maxZoom);\n        for (let i = markers.length - 1; i >= 0; i--) {\n            this._addMarkerBatch(markers[i], minZoom, maxZoom);\n        }\n        this._numMarkers[minZoom] += markers.length;\n    }\n    /**\n     * Returns the value of the optional maximum zoom. This method is defined so\n     * that we have just one place where optional maximum zoom is calculated.\n     *\n     * @param {Number} maxZoom The optinal maximum zoom.\n     * @return The maximum zoom.\n     */\n    _getOptmaxZoom(maxZoom) {\n        return maxZoom || this._maxZoom;\n    }\n    /**\n     * Calculates the total number of markers potentially visible at a given\n     * zoom level.\n     *\n     * @param {Number} zoom The zoom level to check.\n     */\n    getMarkerCount(zoom) {\n        let total = 0;\n        for (let z = 0; z <= zoom; z++) {\n            total += this._numMarkers[z];\n        }\n        return total;\n    }\n    /**\n     * Returns a marker given latitude, longitude and zoom. If the marker does not\n     * exist, the method will return a new marker. If a new marker is created,\n     * it will NOT be added to the manager.\n     *\n     * @param {Number} lat - the latitude of a marker.\n     * @param {Number} lng - the longitude of a marker.\n     * @param {Number} zoom - the zoom level\n     * @return {GMarker} marker - the marker found at lat and lng\n     */\n    getMarker(lat, lng, zoom) {\n        const mPoint = new google.maps.LatLng(lat, lng);\n        const gridPoint = this._getTilePoint(mPoint, zoom, new google.maps.Size(0, 0));\n        let marker = new google.maps.Marker({ position: mPoint });\n        const cell = this._getGridCellNoCreate(gridPoint.x, gridPoint.y, zoom);\n        if (cell !== undefined) {\n            for (let i = 0; i < cell.length; i++) {\n                if (lat === cell[i].getPosition().lat() &&\n                    lng === cell[i].getPosition().lng()) {\n                    marker = cell[i];\n                }\n            }\n        }\n        return marker;\n    }\n    /**\n     * Add a single marker to the map.\n     *\n     * @param {Marker} marker The marker to add.\n     * @param {Number} minZoom The minimum zoom level to display the marker.\n     * @param {Number} maxZoom The maximum zoom level to display the marker.\n     */\n    addMarker(marker, minZoom, maxZoom) {\n        maxZoom = this._getOptmaxZoom(maxZoom);\n        this._addMarkerBatch(marker, minZoom, maxZoom);\n        const gridPoint = this._getTilePoint(marker.getPosition(), this._mapZoom, new google.maps.Size(0, 0));\n        if (this._isGridPointVisible(gridPoint) &&\n            minZoom <= this._shownBounds.z &&\n            this._shownBounds.z <= maxZoom) {\n            this._addOverlay(marker);\n            this._notifyListeners();\n        }\n        this._numMarkers[minZoom]++;\n    }\n    /**\n     * Get a cell in the grid, creating it first if necessary.\n     *\n     * Optimization candidate\n     *\n     * @param {Number} x The x coordinate of the cell.\n     * @param {Number} y The y coordinate of the cell.\n     * @param {Number} z The z coordinate of the cell.\n     * @return {Array} The cell in the array.\n     */\n    _getGridCellCreate(x, y, z) {\n        // TODO document this\n        if (x < 0) {\n            x += this._gridWidth[z];\n        }\n        if (!this._grid[z]) {\n            this._grid[z] = [];\n        }\n        if (!this._grid[z][x]) {\n            this._grid[z][x] = [];\n        }\n        if (!this._grid[z][x][y]) {\n            this._grid[z][x][y] = [];\n        }\n        return this._grid[z][x][y];\n    }\n    /**\n     * Get a cell in the grid, returning undefined if it does not exist.\n     *\n     * NOTE: Optimized for speed -- otherwise could combine with _getGridCellCreate.\n     *\n     * @param {Number} x The x coordinate of the cell.\n     * @param {Number} y The y coordinate of the cell.\n     * @param {Number} z The z coordinate of the cell.\n     * @return {Array} The cell in the array.\n     */\n    _getGridCellNoCreate(x, y, z) {\n        if (x < 0) {\n            x += this._gridWidth[z];\n        }\n        if (!this._grid[z]) {\n            return null;\n        }\n        if (!this._grid[z][x]) {\n            return null;\n        }\n        if (!this._grid[z][x][y]) {\n            return null;\n        }\n        return this._grid[z][x][y];\n    }\n    /**\n     * Turns at geographical bounds into a grid-space bounds.\n     *\n     * @param {LatLngBounds} bounds The geographical bounds.\n     * @param {Number} zoom The zoom level of the bounds.\n     * @param {google.maps.Size} swPadding The padding in pixels to extend beyond the\n     * given bounds.\n     * @param {google.maps.Size} nePadding The padding in pixels to extend beyond the\n     * given bounds.\n     * @return {GridBounds} The bounds in grid space.\n     */\n    _getGridBounds(bounds, zoom, swPadding, nePadding) {\n        zoom = Math.min(zoom, this._maxZoom);\n        const bl = bounds.getSouthWest();\n        const tr = bounds.getNorthEast();\n        const sw = this._getTilePoint(bl, zoom, swPadding);\n        const ne = this._getTilePoint(tr, zoom, nePadding);\n        const gw = this._gridWidth[zoom];\n        // Crossing the prime meridian requires correction of bounds.\n        if (tr.lng() < bl.lng() || ne.x < sw.x) {\n            sw.x -= gw;\n        }\n        if (ne.x - sw.x + 1 >= gw) {\n            // Computed grid bounds are larger than the world; truncate.\n            sw.x = 0;\n            ne.x = gw - 1;\n        }\n        const gridBounds = new GridBounds([sw, ne], zoom);\n        gridBounds.z = zoom;\n        return gridBounds;\n    }\n    /**\n     * Gets the grid-space bounds for the current map viewport.\n     *\n     * @return {Bounds} The bounds in grid space.\n     */\n    _getMapGridBounds() {\n        return this._getGridBounds(this._map.getBounds(), this._mapZoom, this._swPadding, this._nePadding);\n    }\n    /**\n     * Event listener for map:movend.\n     * NOTE: Use a timeout so that the user is not blocked\n     * from moving the map.\n     *\n     * Removed this because a a lack of a scopy override/callback function on events.\n     */\n    _onMapMoveEnd() {\n        window.setTimeout(this._updateMarkers.bind(this), 0);\n    }\n    /**\n     * Is this layer visible?\n     *\n     * Returns visibility setting\n     *\n     * @return {Boolean} Visible\n     */\n    visible() {\n        return this.shown ? true : false;\n    }\n    /**\n     * Returns true if the manager is hidden.\n     * Otherwise returns false.\n     * @return {Boolean} Hidden\n     */\n    isHidden() {\n        return !this.shown;\n    }\n    /**\n     * Shows the manager if it's currently hidden.\n     */\n    show() {\n        this.shown = true;\n        this.refresh();\n    }\n    /**\n     * Hides the manager if it's currently visible\n     */\n    hide() {\n        this.shown = false;\n        this.refresh();\n    }\n    /**\n     * Toggles the visibility of the manager.\n     */\n    toggle() {\n        this.shown = !this.shown;\n        this.refresh();\n    }\n    /**\n     * Refresh forces the marker-manager into a good state.\n     * <ol>\n     *   <li>If never before initialized, shows all the markers.</li>\n     *   <li>If previously initialized, removes and re-adds all markers.</li>\n     * </ol>\n     */\n    refresh() {\n        if (this.shownMarkers > 0) {\n            this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n        }\n        // An extra check on this.show to increase performance (no need to _processAll_)\n        if (this.show) {\n            this._processAll(this._shownBounds, this._addOverlay.bind(this));\n        }\n        this._notifyListeners();\n    }\n    /**\n     * After the viewport may have changed, add or remove markers as needed.\n     */\n    _updateMarkers() {\n        this._mapZoom = this._map.getZoom();\n        const newBounds = this._getMapGridBounds();\n        // If the move does not include new grid sections,\n        // we have no work to do:\n        if (newBounds.equals(this._shownBounds) &&\n            newBounds.z === this._shownBounds.z) {\n            return;\n        }\n        if (newBounds.z !== this._shownBounds.z) {\n            this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n            if (this.show) {\n                // performance\n                this._processAll(newBounds, this._addOverlay.bind(this));\n            }\n        }\n        else {\n            // Remove markers:\n            this._rectangleDiff(this._shownBounds, newBounds, this._removeCellMarkers.bind(this));\n            // Add markers:\n            if (this.show) {\n                // performance\n                this._rectangleDiff(newBounds, this._shownBounds, this._addCellMarkers.bind(this));\n            }\n        }\n        this._shownBounds = newBounds;\n        this._notifyListeners();\n    }\n    /**\n     * Notify listeners when the state of what is displayed changes.\n     */\n    _notifyListeners() {\n        google.maps.event.trigger(this, \"changed\", this._shownBounds, this.shownMarkers);\n    }\n    /**\n     * Process all markers in the bounds provided, using a callback.\n     *\n     * @param {Bounds} bounds The bounds in grid space.\n     * @param {Function} callback The function to call for each marker.\n     */\n    _processAll(bounds, callback) {\n        for (let x = bounds.minX; x <= bounds.maxX; x++) {\n            for (let y = bounds.minY; y <= bounds.maxY; y++) {\n                this._processCellMarkers(x, y, bounds.z, callback);\n            }\n        }\n    }\n    /**\n     * Process all markers in the grid cell, using a callback.\n     *\n     * @param {Number} x The x coordinate of the cell.\n     * @param {Number} y The y coordinate of the cell.\n     * @param {Number} z The z coordinate of the cell.\n     * @param {Function} callback The function to call for each marker.\n     */\n    _processCellMarkers(x, y, z, callback) {\n        const cell = this._getGridCellNoCreate(x, y, z);\n        if (cell) {\n            for (let i = cell.length - 1; i >= 0; i--) {\n                callback(cell[i]);\n            }\n        }\n    }\n    /**\n     * Remove all markers in a grid cell.\n     *\n     * @param {Number} x The x coordinate of the cell.\n     * @param {Number} y The y coordinate of the cell.\n     * @param {Number} z The z coordinate of the cell.\n     */\n    _removeCellMarkers(x, y, z) {\n        this._processCellMarkers(x, y, z, this._removeOverlay.bind(this));\n    }\n    /**\n     * Add all markers in a grid cell.\n     *\n     * @param {Number} x The x coordinate of the cell.\n     * @param {Number} y The y coordinate of the cell.\n     * @param {Number} z The z coordinate of the cell.\n     */\n    _addCellMarkers(x, y, z) {\n        this._processCellMarkers(x, y, z, this._addOverlay.bind(this));\n    }\n    /**\n     * Use the _rectangleDiffCoords function to process all grid cells\n     * that are in bounds1 but not bounds2, using a callback, and using\n     * the current MarkerManager object as the instance.\n     *\n     * Pass the z parameter to the callback in addition to x and y.\n     *\n     * @param {Bounds} bounds1 The bounds of all points we may _process.\n     * @param {Bounds} bounds2 The bounds of points to exclude.\n     * @param {Function} callback The callback function to call\n     *                   for each grid coordinate (x, y, z).\n     */\n    _rectangleDiff(bounds1, bounds2, callback) {\n        this._rectangleDiffCoords(bounds1, bounds2, (x, y) => {\n            callback(x, y, bounds1.z);\n        });\n    }\n    /**\n     * Calls the function for all points in bounds1, not in bounds2\n     *\n     * @param {Bounds} bounds1 The bounds of all points we may process.\n     * @param {Bounds} bounds2 The bounds of points to exclude.\n     * @param {Function} callback The callback function to call\n     *                   for each grid coordinate.\n     */\n    _rectangleDiffCoords(bounds1, bounds2, callback) {\n        const minX1 = bounds1.minX;\n        const minY1 = bounds1.minY;\n        const maxX1 = bounds1.maxX;\n        const maxY1 = bounds1.maxY;\n        const minX2 = bounds2.minX;\n        const minY2 = bounds2.minY;\n        const maxX2 = bounds2.maxX;\n        const maxY2 = bounds2.maxY;\n        let x, y;\n        for (x = minX1; x <= maxX1; x++) {\n            // All x in R1\n            // All above:\n            for (y = minY1; y <= maxY1 && y < minY2; y++) {\n                // y in R1 above R2\n                callback(x, y);\n            }\n            // All below:\n            for (y = Math.max(maxY2 + 1, minY1); // y in R1 below R2\n             y <= maxY1; y++) {\n                callback(x, y);\n            }\n        }\n        for (y = Math.max(minY1, minY2); y <= Math.min(maxY1, maxY2); y++) {\n            // All y in R2 and in R1\n            // Strictly left:\n            for (x = Math.min(maxX1 + 1, minX2) - 1; x >= minX1; x--) {\n                // x in R1 left of R2\n                callback(x, y);\n            }\n            // Strictly right:\n            for (x = Math.max(minX1, maxX2 + 1); // x in R1 right of R2\n             x <= maxX1; x++) {\n                callback(x, y);\n            }\n        }\n    }\n    /**\n     * Removes marker from cell. O(N).\n     */\n    _removeMarkerFromCell(cell, marker) {\n        let shift = 0;\n        for (let i = 0; i < cell.length; ++i) {\n            if (cell[i] === marker) {\n                cell.splice(i--, 1);\n                shift++;\n            }\n        }\n        return shift;\n    }\n}\nexport { MarkerManager };\n//# sourceMappingURL=markermanager.js.map"],"names":["latLngToPixel","latlng","zoom","google","maps","Point","lng","lat","sinofphi","Math","sin","PI","log","latToY","GridBounds","constructor","bounds","z","this","minX","min","x","maxX","max","minY","y","maxY","equals","gridBounds","containsPoint","point","map","_ref","maxZoom","trackMarkers","shown","borderPadding","_tileSize","_map","_mapZoom","getZoom","_maxZoom","_trackMarkers","_swPadding","Size","_nePadding","_gridWidth","_grid","_numMarkers","shownMarkers","event","addListenerOnce","_initialize","mapTypes","sType","get","addListener","_onMapMoveEnd","bind","resetManager","_shownBounds","_getMapGridBounds","trigger","_removeOverlay","marker","setMap","_addOverlay","mapWidth","ceil","clearMarkers","_processAll","_getTilePoint","padding","pixelPoint","floor","width","height","_addMarkerBatch","minZoom","mPoint","getPosition","set","oldPoint","newPoint","_onMarkerMoved","gridPoint","_getGridCellCreate","push","_isGridPointVisible","vertical","horizontal","changed","oldGrid","newGrid","cell","_getGridCellNoCreate","_removeMarkerFromCell","_notifyListeners","removeMarker","grid","addMarkers","markers","_getOptmaxZoom","i","length","getMarkerCount","total","getMarker","LatLng","Marker","position","undefined","addMarker","_getGridBounds","swPadding","nePadding","bl","getSouthWest","tr","getNorthEast","sw","ne","gw","getBounds","window","setTimeout","_updateMarkers","visible","isHidden","show","refresh","hide","toggle","newBounds","_rectangleDiff","_removeCellMarkers","_addCellMarkers","callback","_processCellMarkers","bounds1","bounds2","_rectangleDiffCoords","minX1","minY1","maxX1","maxY1","minX2","minY2","maxX2","maxY2","shift","splice"],"mappings":"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"}