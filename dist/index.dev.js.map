{"version":3,"file":"index.dev.js","sources":["../src/utils.ts","../src/gridbounds.ts","../src/markermanager.ts"],"sourcesContent":["/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @ignore\n *\n * @param lng\n */\nfunction lngToX(lng: number): number {\n  return 1 + lng / 180;\n}\n/**\n * @ignore\n *\n * @param {number} lat\n * @returns {number}\n */\nfunction latToY(lat: number): number {\n  const sinofphi = Math.sin((lat * Math.PI) / 180);\n  return 1 - (0.5 / Math.PI) * Math.log((1 + sinofphi) / (1 - sinofphi));\n}\n\n/**\n * @ignore\n *\n * @param latlng\n * @param zoom\n */\nexport function latLngToPixel(\n  latlng: google.maps.LatLng,\n  zoom: number\n): google.maps.Point {\n  return new google.maps.Point(\n    ~~(0.5 + lngToX(latlng.lng()) * (2 << (zoom + 6))),\n    ~~(0.5 + latToY(latlng.lat()) * (2 << (zoom + 6)))\n  );\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Helper class to create a bounds of INT ranges.\n * @ignore\n */\nexport class GridBounds {\n  public z: number;\n  public minX: number;\n  public maxX: number;\n  public minY: number;\n  public maxY: number;\n\n  /**\n   *\n   * @param bounds\n   * @param z\n   */\n  constructor(bounds: google.maps.Point[], z: number) {\n    // [sw, ne]\n    this.z = z;\n    this.minX = Math.min(bounds[0].x, bounds[1].x);\n    this.maxX = Math.max(bounds[0].x, bounds[1].x);\n    this.minY = Math.min(bounds[0].y, bounds[1].y);\n    this.maxY = Math.max(bounds[0].y, bounds[1].y);\n  }\n\n  /**\n   * Returns true if this bounds equal the given bounds.\n   * @param {GridBounds} gridBounds GridBounds The bounds to test.\n   * @return {Boolean} This Bounds equals the given GridBounds.\n   */\n  equals(gridBounds: GridBounds): boolean {\n    if (\n      this.maxX === gridBounds.maxX &&\n      this.maxY === gridBounds.maxY &&\n      this.minX === gridBounds.minX &&\n      this.minY === gridBounds.minY\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns true if this bounds (inclusively) contains the given point.\n   * @param {Point} point  The point to test.\n   * @return {Boolean} This Bounds contains the given Point.\n   */\n  containsPoint(point: google.maps.Point): boolean {\n    return (\n      this.minX <= point.x &&\n      this.maxX >= point.x &&\n      this.minY <= point.y &&\n      this.maxY >= point.y\n    );\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/// <reference types=\"@types/google.maps\" />\n\nimport { latLngToPixel } from \"./utils\";\nimport { GridBounds } from \"./gridbounds\";\n\ninterface Options {\n  maxZoom?: number;\n  shown?: boolean;\n  trackMarkers?: boolean;\n  borderPadding?: number;\n}\n\n/**\n * Creates a new MarkerManager that will show/hide markers on a map.\n */\nclass MarkerManager {\n  public shown: boolean;\n  public shownMarkers: number;\n\n  private _map: google.maps.Map;\n  private _mapZoom: number;\n  private _maxZoom: number;\n  private _tileSize = 1024;\n  private _trackMarkers: boolean;\n  private _swPadding: google.maps.Size;\n  private _nePadding: google.maps.Size;\n  private _gridWidth: { [k: string]: number };\n  private _grid: google.maps.Marker[][][][];\n  private _numMarkers: { [k: string]: number };\n  private _shownBounds: GridBounds;\n\n  /**\n   * @constructor\n   * @param map The map to manage.\n   * @param {Options} options\n   */\n  constructor(\n    map: google.maps.Map,\n    { maxZoom = 19, trackMarkers, shown = true, borderPadding = 100 }: Options\n  ) {\n    this._map = map;\n    this._mapZoom = map.getZoom();\n    this._maxZoom = maxZoom;\n    this._trackMarkers = trackMarkers;\n\n    // The padding in pixels beyond the viewport, where we will pre-load markers.\n    this._swPadding = new google.maps.Size(-borderPadding, borderPadding);\n    this._nePadding = new google.maps.Size(borderPadding, -borderPadding);\n\n    this._gridWidth = {};\n    this._grid = [];\n    this._grid[this._maxZoom] = [];\n    this._numMarkers = {};\n    this._numMarkers[this._maxZoom] = 0;\n\n    this.shownMarkers = 0;\n    this.shown = shown;\n\n    google.maps.event.addListenerOnce(map, \"idle\", () => {\n      this._initialize();\n    });\n  }\n\n  private _initialize(): void {\n    const mapTypes = this._map.mapTypes;\n\n    // Find max zoom level\n    let mapMaxZoom = 1;\n    for (const sType in mapTypes) {\n      if (\n        sType in mapTypes &&\n        mapTypes.get(sType) &&\n        mapTypes.get(sType).maxZoom === \"number\"\n      ) {\n        const mapTypeMaxZoom = this._map.mapTypes.get(sType).maxZoom;\n        if (mapTypeMaxZoom > mapMaxZoom) {\n          mapMaxZoom = mapTypeMaxZoom;\n        }\n      }\n    }\n\n    google.maps.event.addListener(\n      this._map,\n      \"dragend\",\n      this._onMapMoveEnd.bind(this)\n    );\n\n    google.maps.event.addListener(\n      this._map,\n      \"idle\",\n      this._onMapMoveEnd.bind(this)\n    );\n\n    google.maps.event.addListener(\n      this._map,\n      \"zoom_changed\",\n      this._onMapMoveEnd.bind(this)\n    );\n\n    this.resetManager();\n\n    this._shownBounds = this._getMapGridBounds();\n\n    google.maps.event.trigger(this, \"loaded\");\n  }\n  /**\n   * This closure provide easy access to the map.\n   * They are used as callbacks, not as methods.\n   * @param marker Marker to be removed from the map\n   */\n  private _removeOverlay(marker: google.maps.Marker): void {\n    marker.setMap(null);\n    this.shownMarkers--;\n  }\n\n  /**\n   * This closure provide easy access to the map.\n   * They are used as callbacks, not as methods.\n   * @param marker Marker to be added to the map\n   */\n  private _addOverlay(marker: google.maps.Marker): void {\n    if (this.shown) {\n      marker.setMap(this._map);\n      this.shownMarkers++;\n    }\n  }\n\n  /**\n   * Initializes MarkerManager arrays for all zoom levels\n   * Called by constructor and by clearAllMarkers\n   */\n  public resetManager(): void {\n    let mapWidth = 256;\n    for (let zoom = 0; zoom <= this._maxZoom; ++zoom) {\n      this._grid[zoom] = [];\n      this._numMarkers[zoom] = 0;\n      this._gridWidth[zoom] = Math.ceil(mapWidth / this._tileSize);\n      mapWidth <<= 1;\n    }\n  }\n\n  /**\n   * Removes all markers in the manager, and\n   * removes any visible markers from the map.\n   */\n  public clearMarkers(): void {\n    this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n    this.resetManager();\n  }\n\n  /**\n   * Gets the tile coordinate for a given latlng point.\n   *\n   * @param {LatLng} latlng The geographical point.\n   * @param {Number} zoom The zoom level.\n   * @param {google.maps.Size} padding The padding used to shift the pixel coordinate.\n   *               Used for expanding a bounds to include an extra padding\n   *               of pixels surrounding the bounds.\n   * @return {GPoint} The point in tile coordinates.\n   *\n   */\n  private _getTilePoint(\n    latlng: google.maps.LatLng,\n    zoom: number,\n    padding: google.maps.Size\n  ): google.maps.Point {\n    const pixelPoint = latLngToPixel(latlng, zoom);\n\n    const point = new google.maps.Point(\n      Math.floor((pixelPoint.x + padding.width) / this._tileSize),\n      Math.floor((pixelPoint.y + padding.height) / this._tileSize)\n    );\n\n    return point;\n  }\n\n  /**\n   * Finds the appropriate place to add the marker to the grid.\n   * Optimized for speed; does not actually add the marker to the map.\n   * Designed for batch-_processing thousands of markers.\n   *\n   * @param {Marker} marker The marker to add.\n   * @param {Number} minZoom The minimum zoom for displaying the marker.\n   * @param {Number} maxZoom The maximum zoom for displaying the marker.\n   */\n  private _addMarkerBatch(\n    marker: google.maps.Marker,\n    minZoom: number,\n    maxZoom: number\n  ): void {\n    const mPoint = marker.getPosition();\n    marker.set(\"__minZoom\", minZoom);\n\n    // Tracking markers is expensive, so we do this only if the\n    // user explicitly requested it when creating marker manager.\n    if (this._trackMarkers) {\n      google.maps.event.addListener(\n        marker,\n        \"changed\",\n        (\n          marker: google.maps.Marker,\n          oldPoint: google.maps.LatLng,\n          newPoint: google.maps.LatLng\n        ) => {\n          this._onMarkerMoved(marker, oldPoint, newPoint);\n        }\n      );\n    }\n\n    const gridPoint = this._getTilePoint(\n      mPoint,\n      maxZoom,\n      new google.maps.Size(0, 0)\n    );\n\n    for (let zoom = maxZoom; zoom >= minZoom; zoom--) {\n      const cell = this._getGridCellCreate(gridPoint.x, gridPoint.y, zoom);\n      cell.push(marker);\n\n      gridPoint.x = gridPoint.x >> 1;\n      gridPoint.y = gridPoint.y >> 1;\n    }\n  }\n\n  /**\n   * Returns whether or not the given point is visible in the shown bounds. This\n   * is a helper method that takes care of the corner case, when shownBounds have\n   * negative minX value.\n   *\n   * @param {Point} point a point on a grid.\n   * @return {Boolean} Whether or not the given point is visible in the currently\n   * shown bounds.\n   */\n  private _isGridPointVisible(point: google.maps.Point): boolean {\n    const vertical =\n      this._shownBounds.minY <= point.y && point.y <= this._shownBounds.maxY;\n    const minX = this._shownBounds.minX;\n    let horizontal = minX <= point.x && point.x <= this._shownBounds.maxX;\n    if (!horizontal && minX < 0) {\n      // Shifts the negative part of the rectangle. As point.x is always less\n      // than grid width, only test shifted minX .. 0 part of the shown bounds.\n      const width = this._gridWidth[this._shownBounds.z];\n      horizontal = minX + width <= point.x && point.x <= width - 1;\n    }\n    return vertical && horizontal;\n  }\n\n  /**\n   * Reacts to a notification from a marker that it has moved to a new location.\n   * It scans the grid all all zoom levels and moves the marker from the old grid\n   * location to a new grid location.\n   *\n   * @param {Marker} marker The marker that moved.\n   * @param {LatLng} oldPoint The old position of the marker.\n   * @param {LatLng} newPoint The new position of the marker.\n   */\n  private _onMarkerMoved(\n    marker: google.maps.Marker,\n    oldPoint: google.maps.LatLng,\n    newPoint: google.maps.LatLng\n  ): void {\n    // NOTE: We do not know the minimum or maximum zoom the marker was\n    // added at, so we start at the absolute maximum. Whenever we successfully\n    // remove a marker at a given zoom, we add it at the new grid coordinates.\n    let zoom = this._maxZoom;\n    let changed = false;\n    const oldGrid = this._getTilePoint(\n      oldPoint,\n      zoom,\n      new google.maps.Size(0, 0)\n    );\n    const newGrid = this._getTilePoint(\n      newPoint,\n      zoom,\n      new google.maps.Size(0, 0)\n    );\n    while (zoom >= 0 && (oldGrid.x !== newGrid.x || oldGrid.y !== newGrid.y)) {\n      const cell = this._getGridCellNoCreate(oldGrid.x, oldGrid.y, zoom);\n      if (cell) {\n        if (this._removeMarkerFromCell(cell, marker)) {\n          this._getGridCellCreate(newGrid.x, newGrid.y, zoom).push(marker);\n        }\n      }\n      // For the current zoom we also need to update the map. Markers that no\n      // longer are visible are removed from the map. Markers that moved into\n      // the shown bounds are added to the map. This also lets us keep the count\n      // of visible markers up to date.\n      if (zoom === this._mapZoom) {\n        if (this._isGridPointVisible(oldGrid)) {\n          if (!this._isGridPointVisible(newGrid)) {\n            this._removeOverlay(marker);\n            changed = true;\n          }\n        } else {\n          if (this._isGridPointVisible(newGrid)) {\n            this._addOverlay(marker);\n            changed = true;\n          }\n        }\n      }\n      oldGrid.x = oldGrid.x >> 1;\n      oldGrid.y = oldGrid.y >> 1;\n      newGrid.x = newGrid.x >> 1;\n      newGrid.y = newGrid.y >> 1;\n      --zoom;\n    }\n    if (changed) {\n      this._notifyListeners();\n    }\n  }\n\n  /**\n   * Removes marker from the manager and from the map\n   * (if it's currently visible).\n   * @param {GMarker} marker The marker to delete.\n   */\n  public removeMarker(marker: google.maps.Marker): void {\n    let zoom = this._maxZoom;\n    let changed = false;\n    const point = marker.getPosition();\n    const grid = this._getTilePoint(point, zoom, new google.maps.Size(0, 0));\n    while (zoom >= 0) {\n      const cell = this._getGridCellNoCreate(grid.x, grid.y, zoom);\n\n      if (cell) {\n        this._removeMarkerFromCell(cell, marker);\n      }\n      // For the current zoom we also need to update the map. Markers that no\n      // longer are visible are removed from the map. This also lets us keep the count\n      // of visible markers up to date.\n      if (zoom === this._mapZoom) {\n        if (this._isGridPointVisible(grid)) {\n          this._removeOverlay(marker);\n          changed = true;\n        }\n      }\n      grid.x = grid.x >> 1;\n      grid.y = grid.y >> 1;\n      --zoom;\n    }\n    if (changed) {\n      this._notifyListeners();\n    }\n    this._numMarkers[marker.get(\"__minZoom\")]--;\n  }\n\n  /**\n   * Add many markers at once.\n   * Does not actually update the map, just the internal grid.\n   *\n   * @param {Array of Marker} markers The markers to add.\n   * @param {Number} minZoom The minimum zoom level to display the markers.\n   * @param {Number} maxZoom The maximum zoom level to display the markers.\n   */\n  public addMarkers(\n    markers: google.maps.Marker[],\n    minZoom: number,\n    maxZoom: number\n  ): void {\n    maxZoom = this._getOptmaxZoom(maxZoom);\n    for (let i = markers.length - 1; i >= 0; i--) {\n      this._addMarkerBatch(markers[i], minZoom, maxZoom);\n    }\n\n    this._numMarkers[minZoom] += markers.length;\n  }\n\n  /**\n   * Returns the value of the optional maximum zoom. This method is defined so\n   * that we have just one place where optional maximum zoom is calculated.\n   *\n   * @param {Number} maxZoom The optinal maximum zoom.\n   * @return The maximum zoom.\n   */\n  private _getOptmaxZoom(maxZoom: number): number {\n    return maxZoom || this._maxZoom;\n  }\n\n  /**\n   * Calculates the total number of markers potentially visible at a given\n   * zoom level.\n   *\n   * @param {Number} zoom The zoom level to check.\n   */\n  public getMarkerCount(zoom: number): number {\n    let total = 0;\n    for (let z = 0; z <= zoom; z++) {\n      total += this._numMarkers[z];\n    }\n    return total;\n  }\n\n  /**\n   * Returns a marker given latitude, longitude and zoom. If the marker does not\n   * exist, the method will return a new marker. If a new marker is created,\n   * it will NOT be added to the manager.\n   *\n   * @param {Number} lat - the latitude of a marker.\n   * @param {Number} lng - the longitude of a marker.\n   * @param {Number} zoom - the zoom level\n   * @return {GMarker} marker - the marker found at lat and lng\n   */\n  public getMarker(lat: number, lng: number, zoom: number): google.maps.Marker {\n    const mPoint = new google.maps.LatLng(lat, lng);\n    const gridPoint = this._getTilePoint(\n      mPoint,\n      zoom,\n      new google.maps.Size(0, 0)\n    );\n\n    let marker = new google.maps.Marker({ position: mPoint });\n\n    const cell = this._getGridCellNoCreate(gridPoint.x, gridPoint.y, zoom);\n    if (cell !== undefined) {\n      for (let i = 0; i < cell.length; i++) {\n        if (\n          lat === cell[i].getPosition().lat() &&\n          lng === cell[i].getPosition().lng()\n        ) {\n          marker = cell[i];\n        }\n      }\n    }\n    return marker;\n  }\n\n  /**\n   * Add a single marker to the map.\n   *\n   * @param {Marker} marker The marker to add.\n   * @param {Number} minZoom The minimum zoom level to display the marker.\n   * @param {Number} maxZoom The maximum zoom level to display the marker.\n   */\n  public addMarker(\n    marker: google.maps.Marker,\n    minZoom: number,\n    maxZoom: number\n  ): void {\n    maxZoom = this._getOptmaxZoom(maxZoom);\n    this._addMarkerBatch(marker, minZoom, maxZoom);\n    const gridPoint = this._getTilePoint(\n      marker.getPosition(),\n      this._mapZoom,\n      new google.maps.Size(0, 0)\n    );\n    if (\n      this._isGridPointVisible(gridPoint) &&\n      minZoom <= this._shownBounds.z &&\n      this._shownBounds.z <= maxZoom\n    ) {\n      this._addOverlay(marker);\n      this._notifyListeners();\n    }\n    this._numMarkers[minZoom]++;\n  }\n\n  /**\n   * Get a cell in the grid, creating it first if necessary.\n   *\n   * Optimization candidate\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   * @return {Array} The cell in the array.\n   */\n  private _getGridCellCreate(\n    x: number,\n    y: number,\n    z: number\n  ): google.maps.Marker[] {\n    // TODO(jpoehnelt) document this\n    if (x < 0) {\n      x += this._gridWidth[z];\n    }\n\n    if (!this._grid[z]) {\n      this._grid[z] = [];\n    }\n    if (!this._grid[z][x]) {\n      this._grid[z][x] = [];\n    }\n    if (!this._grid[z][x][y]) {\n      this._grid[z][x][y] = [];\n    }\n    return this._grid[z][x][y];\n  }\n\n  /**\n   * Get a cell in the grid, returning undefined if it does not exist.\n   *\n   * NOTE: Optimized for speed -- otherwise could combine with _getGridCellCreate.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   * @return {Array} The cell in the array.\n   */\n  private _getGridCellNoCreate(\n    x: number,\n    y: number,\n    z: number\n  ): google.maps.Marker[] | null {\n    if (x < 0) {\n      x += this._gridWidth[z];\n    }\n\n    if (!this._grid[z]) {\n      return null;\n    }\n    if (!this._grid[z][x]) {\n      return null;\n    }\n    if (!this._grid[z][x][y]) {\n      return null;\n    }\n    return this._grid[z][x][y];\n  }\n\n  /**\n   * Turns at geographical bounds into a grid-space bounds.\n   *\n   * @param {LatLngBounds} bounds The geographical bounds.\n   * @param {Number} zoom The zoom level of the bounds.\n   * @param {google.maps.Size} swPadding The padding in pixels to extend beyond the\n   * given bounds.\n   * @param {google.maps.Size} nePadding The padding in pixels to extend beyond the\n   * given bounds.\n   * @return {GridBounds} The bounds in grid space.\n   */\n  private _getGridBounds(\n    bounds: google.maps.LatLngBounds,\n    zoom: number,\n    swPadding: google.maps.Size,\n    nePadding: google.maps.Size\n  ): GridBounds {\n    zoom = Math.min(zoom, this._maxZoom);\n\n    const bl = bounds.getSouthWest();\n    const tr = bounds.getNorthEast();\n    const sw = this._getTilePoint(bl, zoom, swPadding);\n\n    const ne = this._getTilePoint(tr, zoom, nePadding);\n    const gw = this._gridWidth[zoom];\n\n    // Crossing the prime meridian requires correction of bounds.\n    if (tr.lng() < bl.lng() || ne.x < sw.x) {\n      sw.x -= gw;\n    }\n    if (ne.x - sw.x + 1 >= gw) {\n      // Computed grid bounds are larger than the world; truncate.\n      sw.x = 0;\n      ne.x = gw - 1;\n    }\n\n    const gridBounds = new GridBounds([sw, ne], zoom);\n    gridBounds.z = zoom;\n\n    return gridBounds;\n  }\n\n  /**\n   * Gets the grid-space bounds for the current map viewport.\n   *\n   * @return {Bounds} The bounds in grid space.\n   */\n  private _getMapGridBounds(): GridBounds {\n    return this._getGridBounds(\n      this._map.getBounds(),\n      this._mapZoom,\n      this._swPadding,\n      this._nePadding\n    );\n  }\n\n  /**\n   * Event listener for map:movend.\n   * NOTE: Use a timeout so that the user is not blocked\n   * from moving the map.\n   *\n   * Removed this because a a lack of a scopy override/callback function on events.\n   */\n  private _onMapMoveEnd(): void {\n    window.setTimeout(this._updateMarkers.bind(this), 0);\n  }\n\n  /**\n   * Is this layer visible?\n   *\n   * Returns visibility setting\n   *\n   * @return {Boolean} Visible\n   */\n  public visible(): boolean {\n    return this.shown ? true : false;\n  }\n\n  /**\n   * Returns true if the manager is hidden.\n   * Otherwise returns false.\n   * @return {Boolean} Hidden\n   */\n  public isHidden(): boolean {\n    return !this.shown;\n  }\n\n  /**\n   * Shows the manager if it's currently hidden.\n   */\n  public show(): void {\n    this.shown = true;\n    this.refresh();\n  }\n\n  /**\n   * Hides the manager if it's currently visible\n   */\n  public hide(): void {\n    this.shown = false;\n    this.refresh();\n  }\n\n  /**\n   * Toggles the visibility of the manager.\n   */\n  public toggle(): void {\n    this.shown = !this.shown;\n    this.refresh();\n  }\n\n  /**\n   * Refresh forces the marker-manager into a good state.\n   * <ol>\n   *   <li>If never before initialized, shows all the markers.</li>\n   *   <li>If previously initialized, removes and re-adds all markers.</li>\n   * </ol>\n   */\n  public refresh(): void {\n    if (this.shownMarkers > 0) {\n      this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n    }\n    // An extra check on this.show to increase performance (no need to _processAll_)\n    if (this.show) {\n      this._processAll(this._shownBounds, this._addOverlay.bind(this));\n    }\n    this._notifyListeners();\n  }\n\n  /**\n   * After the viewport may have changed, add or remove markers as needed.\n   */\n  private _updateMarkers(): void {\n    this._mapZoom = this._map.getZoom();\n    const newBounds = this._getMapGridBounds();\n\n    // If the move does not include new grid sections,\n    // we have no work to do:\n    if (\n      newBounds.equals(this._shownBounds) &&\n      newBounds.z === this._shownBounds.z\n    ) {\n      return;\n    }\n\n    if (newBounds.z !== this._shownBounds.z) {\n      this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n      if (this.show) {\n        // performance\n        this._processAll(newBounds, this._addOverlay.bind(this));\n      }\n    } else {\n      // Remove markers:\n      this._rectangleDiff(\n        this._shownBounds,\n        newBounds,\n        this._removeCellMarkers.bind(this)\n      );\n\n      // Add markers:\n      if (this.show) {\n        // performance\n        this._rectangleDiff(\n          newBounds,\n          this._shownBounds,\n          this._addCellMarkers.bind(this)\n        );\n      }\n    }\n    this._shownBounds = newBounds;\n\n    this._notifyListeners();\n  }\n\n  /**\n   * Notify listeners when the state of what is displayed changes.\n   */\n  private _notifyListeners(): void {\n    google.maps.event.trigger(\n      this,\n      \"changed\",\n      this._shownBounds,\n      this.shownMarkers\n    );\n  }\n\n  /**\n   * Process all markers in the bounds provided, using a callback.\n   *\n   * @param {Bounds} bounds The bounds in grid space.\n   * @param {Function} callback The function to call for each marker.\n   */\n  private _processAll(\n    bounds: GridBounds,\n    callback: (marker: google.maps.Marker) => void\n  ): void {\n    for (let x = bounds.minX; x <= bounds.maxX; x++) {\n      for (let y = bounds.minY; y <= bounds.maxY; y++) {\n        this._processCellMarkers(x, y, bounds.z, callback);\n      }\n    }\n  }\n\n  /**\n   * Process all markers in the grid cell, using a callback.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   * @param {Function} callback The function to call for each marker.\n   */\n  private _processCellMarkers(\n    x: number,\n    y: number,\n    z: number,\n    callback: (marker: google.maps.Marker) => void\n  ): void {\n    const cell = this._getGridCellNoCreate(x, y, z);\n    if (cell) {\n      for (let i = cell.length - 1; i >= 0; i--) {\n        callback(cell[i]);\n      }\n    }\n  }\n\n  /**\n   * Remove all markers in a grid cell.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   */\n  private _removeCellMarkers(x: number, y: number, z: number): void {\n    this._processCellMarkers(x, y, z, this._removeOverlay.bind(this));\n  }\n\n  /**\n   * Add all markers in a grid cell.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   */\n  private _addCellMarkers(x: number, y: number, z: number): void {\n    this._processCellMarkers(x, y, z, this._addOverlay.bind(this));\n  }\n\n  /**\n   * Use the _rectangleDiffCoords function to process all grid cells\n   * that are in bounds1 but not bounds2, using a callback, and using\n   * the current MarkerManager object as the instance.\n   *\n   * Pass the z parameter to the callback in addition to x and y.\n   *\n   * @param {Bounds} bounds1 The bounds of all points we may _process.\n   * @param {Bounds} bounds2 The bounds of points to exclude.\n   * @param {Function} callback The callback function to call\n   *                   for each grid coordinate (x, y, z).\n   */\n  private _rectangleDiff(\n    bounds1: GridBounds,\n    bounds2: GridBounds,\n    callback: (x: number, y: number, z: number) => void\n  ): void {\n    this._rectangleDiffCoords(bounds1, bounds2, (x, y) => {\n      callback(x, y, bounds1.z);\n    });\n  }\n\n  /**\n   * Calls the function for all points in bounds1, not in bounds2\n   *\n   * @param {Bounds} bounds1 The bounds of all points we may process.\n   * @param {Bounds} bounds2 The bounds of points to exclude.\n   * @param {Function} callback The callback function to call\n   *                   for each grid coordinate.\n   */\n  private _rectangleDiffCoords(\n    bounds1: GridBounds,\n    bounds2: GridBounds,\n    callback: (x: number, y: number) => void\n  ): void {\n    const minX1 = bounds1.minX;\n    const minY1 = bounds1.minY;\n    const maxX1 = bounds1.maxX;\n    const maxY1 = bounds1.maxY;\n    const minX2 = bounds2.minX;\n    const minY2 = bounds2.minY;\n    const maxX2 = bounds2.maxX;\n    const maxY2 = bounds2.maxY;\n\n    let x, y;\n    for (x = minX1; x <= maxX1; x++) {\n      // All x in R1\n      // All above:\n      for (y = minY1; y <= maxY1 && y < minY2; y++) {\n        // y in R1 above R2\n        callback(x, y);\n      }\n      // All below:\n      for (\n        y = Math.max(maxY2 + 1, minY1); // y in R1 below R2\n        y <= maxY1;\n        y++\n      ) {\n        callback(x, y);\n      }\n    }\n\n    for (y = Math.max(minY1, minY2); y <= Math.min(maxY1, maxY2); y++) {\n      // All y in R2 and in R1\n      // Strictly left:\n      for (x = Math.min(maxX1 + 1, minX2) - 1; x >= minX1; x--) {\n        // x in R1 left of R2\n        callback(x, y);\n      }\n      // Strictly right:\n      for (\n        x = Math.max(minX1, maxX2 + 1); // x in R1 right of R2\n        x <= maxX1;\n        x++\n      ) {\n        callback(x, y);\n      }\n    }\n  }\n\n  /**\n   * Removes marker from cell. O(N).\n   */\n  private _removeMarkerFromCell(\n    cell: google.maps.Marker[],\n    marker: google.maps.Marker\n  ): number {\n    let shift = 0;\n    for (let i = 0; i < cell.length; ++i) {\n      if (cell[i] === marker) {\n        cell.splice(i--, 1);\n        shift++;\n      }\n    }\n    return shift;\n  }\n}\n\nexport { MarkerManager };\n"],"names":["latLngToPixel","latlng","zoom","google","maps","Point","lng","lat","sinofphi","Math","sin","PI","log","latToY","GridBounds","constructor","bounds","z","minX","min","x","maxX","max","minY","y","maxY","equals","gridBounds","this","containsPoint","point","map","maxZoom","trackMarkers","shown","borderPadding","_map","_mapZoom","getZoom","_maxZoom","_trackMarkers","_swPadding","Size","_nePadding","_gridWidth","_grid","_numMarkers","shownMarkers","event","addListenerOnce","_initialize","mapTypes","sType","get","addListener","_onMapMoveEnd","bind","resetManager","_shownBounds","_getMapGridBounds","trigger","_removeOverlay","marker","setMap","_addOverlay","mapWidth","ceil","_tileSize","clearMarkers","_processAll","_getTilePoint","padding","pixelPoint","floor","width","height","_addMarkerBatch","minZoom","mPoint","getPosition","set","oldPoint","newPoint","_onMarkerMoved","gridPoint","_getGridCellCreate","push","_isGridPointVisible","vertical","horizontal","changed","oldGrid","newGrid","cell","_getGridCellNoCreate","_removeMarkerFromCell","_notifyListeners","removeMarker","grid","addMarkers","markers","_getOptmaxZoom","i","length","getMarkerCount","total","getMarker","LatLng","Marker","position","undefined","addMarker","_getGridBounds","swPadding","nePadding","bl","getSouthWest","tr","getNorthEast","sw","ne","gw","getBounds","window","setTimeout","_updateMarkers","visible","isHidden","show","refresh","hide","toggle","newBounds","_rectangleDiff","_removeCellMarkers","_addCellMarkers","callback","_processCellMarkers","bounds1","bounds2","_rectangleDiffCoords","minX1","minY1","maxX1","maxY1","minX2","minY2","maxX2","maxY2","shift","splice"],"mappings":"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"}